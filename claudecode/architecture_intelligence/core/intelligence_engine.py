"""
Architecture Intelligence Engine
Central orchestrator for deep framework expertise with intelligent pragmatism
"""

import asyncio
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass, field
from datetime import datetime
import json
import logging
from pathlib import Path
from enum import Enum

from .pattern_miner import PatternMiner
from .recommendation_engine import RecommendationEngine
from .knowledge_graph import ArchitectureKnowledgeGraph
from .knowledge_extractor import ArchitectureKnowledgeExtractor, DocumentRelevance


class FrameworkType(Enum):
    """Supported architecture frameworks"""
    TOGAF = "togaf"
    DDD = "ddd"
    C4_MODEL = "c4"
    ZACHMAN = "zachman"
    ARCHIMATE = "archimate"
    DODAF = "dodaf"
    FEAF = "feaf"
    BPMN = "bpmn"
    UML = "uml"
    MICROSERVICES = "microservices"
    EVENT_DRIVEN = "event_driven"
    HEXAGONAL = "hexagonal"
    CLEAN = "clean"
    SERVERLESS = "serverless"
    REACTIVE = "reactive"
    CQRS_ES = "cqrs_es"
    STRIDE = "stride"
    ARC42 = "arc42"
    FOUR_PLUS_ONE = "4+1"


@dataclass
class ArchitectureContext:
    """Context for architecture analysis and recommendations"""
    project_name: str
    domain: str
    industry: Optional[str] = None
    organization_size: Optional[str] = None
    team_size: Optional[int] = None
    technical_stack: List[str] = field(default_factory=list)
    constraints: Dict[str, Any] = field(default_factory=dict)
    goals: List[str] = field(default_factory=list)
    current_state: Optional[Dict[str, Any]] = None
    target_state: Optional[Dict[str, Any]] = None
    timeline: Optional[str] = None
    budget: Optional[str] = None
    compliance_requirements: List[str] = field(default_factory=list)
    quality_attributes: List[str] = field(default_factory=list)
    

@dataclass
class ArchitectureInsight:
    """Insight generated by the intelligence engine"""
    id: str
    type: str  # pattern, recommendation, warning, opportunity
    title: str
    description: str
    frameworks: List[FrameworkType]
    confidence: float  # 0.0 to 1.0
    impact: str  # high, medium, low
    effort: str  # high, medium, low
    priority: int  # 1-10
    rationale: str
    actions: List[Dict[str, Any]]
    references: List[Dict[str, str]]
    timestamp: datetime = field(default_factory=datetime.now)


class ArchitectureIntelligenceEngine:
    """
    Main orchestrator for architecture intelligence platform
    Provides deep framework expertise with intelligent cross-framework insights
    """
    
    def __init__(self, config_path: Optional[Path] = None):
        self.logger = logging.getLogger(__name__)
        self.config = self._load_config(config_path)
        
        # Core components
        self.pattern_miner = PatternMiner()
        self.recommendation_engine = RecommendationEngine()
        self.knowledge_graph = ArchitectureKnowledgeGraph()
        self.knowledge_extractor = ArchitectureKnowledgeExtractor()
        
        # Framework registry (will be populated dynamically)
        self.frameworks: Dict[FrameworkType, Any] = {}
        
        # Intelligence cache
        self.insights_cache: Dict[str, List[ArchitectureInsight]] = {}
        
        # Learning data
        self.usage_metrics: Dict[str, Any] = {}
        self.feedback_data: List[Dict[str, Any]] = []
        
        self._initialize_frameworks()
        
    def _load_config(self, config_path: Optional[Path]) -> Dict[str, Any]:
        """Load configuration from file or use defaults"""
        default_config = {
            "intelligence": {
                "min_confidence_threshold": 0.7,
                "max_recommendations": 10,
                "pattern_mining_depth": 3,
                "cross_framework_analysis": True
            },
            "frameworks": {
                "load_all": True,
                "preferred_frameworks": ["togaf", "ddd", "c4"],
                "depth_level": "expert"  # expert, intermediate, basic
            },
            "pragmatic": {
                "prioritize_actionable": True,
                "include_quick_wins": True,
                "generate_implementation_plans": True
            },
            "learning": {
                "enabled": True,
                "feedback_weight": 0.3,
                "pattern_discovery": True
            }
        }
        
        if config_path and config_path.exists():
            with open(config_path, 'r') as f:
                user_config = json.load(f)
                # Deep merge with defaults
                return self._deep_merge(default_config, user_config)
        
        return default_config
    
    def _deep_merge(self, base: Dict, update: Dict) -> Dict:
        """Deep merge two dictionaries"""
        result = base.copy()
        for key, value in update.items():
            if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                result[key] = self._deep_merge(result[key], value)
            else:
                result[key] = value
        return result
    
    def _initialize_frameworks(self):
        """Initialize all framework modules"""
        # This will be implemented to dynamically load framework modules
        self.logger.info("Initializing architecture frameworks...")
        
        # For now, create placeholder entries
        for framework_type in FrameworkType:
            self.frameworks[framework_type] = {
                "loaded": False,
                "module": None,
                "capabilities": []
            }
    
    async def analyze_architecture(
        self,
        context: ArchitectureContext,
        frameworks: Optional[List[FrameworkType]] = None,
        depth: str = "expert"
    ) -> Dict[str, Any]:
        """
        Perform comprehensive architecture analysis using specified frameworks
        
        Args:
            context: Architecture context and requirements
            frameworks: List of frameworks to use (None = auto-select)
            depth: Analysis depth (expert, intermediate, basic)
            
        Returns:
            Comprehensive analysis results with insights and recommendations
        """
        self.logger.info(f"Starting architecture analysis for {context.project_name}")
        
        # Auto-select frameworks if not specified
        if not frameworks:
            frameworks = await self._select_frameworks(context)
        
        # Perform parallel analysis across frameworks
        analysis_tasks = []
        for framework in frameworks:
            task = self._analyze_with_framework(context, framework, depth)
            analysis_tasks.append(task)
        
        framework_results = await asyncio.gather(*analysis_tasks)
        
        # Mine patterns across framework results
        patterns = await self.pattern_miner.mine_patterns(
            framework_results,
            context,
            self.config["intelligence"]["pattern_mining_depth"]
        )
        
        # Generate intelligent recommendations
        recommendations = await self.recommendation_engine.generate_recommendations(
            context,
            framework_results,
            patterns,
            self.config["intelligence"]["max_recommendations"]
        )
        
        # Create unified insights
        insights = self._create_insights(
            framework_results,
            patterns,
            recommendations,
            context
        )
        
        # Update knowledge graph
        await self.knowledge_graph.update_with_insights(
            context.project_name,
            insights,
            framework_results
        )
        
        # Cache insights for learning
        self._cache_insights(context.project_name, insights)
        
        return {
            "context": context,
            "frameworks_used": [f.value for f in frameworks],
            "analysis_depth": depth,
            "framework_results": framework_results,
            "patterns": patterns,
            "recommendations": recommendations,
            "insights": insights,
            "summary": self._create_executive_summary(insights),
            "next_steps": self._generate_next_steps(insights, context),
            "timestamp": datetime.now().isoformat()
        }
    
    async def _select_frameworks(self, context: ArchitectureContext) -> List[FrameworkType]:
        """Intelligently select appropriate frameworks based on context"""
        selected = []
        
        # Enterprise architecture needs
        if context.organization_size in ["large", "enterprise"] or context.compliance_requirements:
            selected.extend([FrameworkType.TOGAF, FrameworkType.ARCHIMATE])
        
        # Domain complexity
        if "complex-domain" in context.goals or "domain-driven" in context.goals:
            selected.append(FrameworkType.DDD)
        
        # System design needs
        selected.append(FrameworkType.C4_MODEL)  # Always useful
        
        # Government/Defense
        if context.industry in ["government", "defense"]:
            selected.append(FrameworkType.DODAF)
        
        # Architectural style
        if "microservices" in str(context.technical_stack):
            selected.append(FrameworkType.MICROSERVICES)
        
        if "event-driven" in context.goals:
            selected.append(FrameworkType.EVENT_DRIVEN)
        
        # Security requirements
        if "security" in context.quality_attributes:
            selected.append(FrameworkType.STRIDE)
        
        # Remove duplicates and limit based on config
        selected = list(set(selected))
        
        # Add preferred frameworks if not already included
        for preferred in self.config["frameworks"]["preferred_frameworks"]:
            framework_type = FrameworkType(preferred)
            if framework_type not in selected:
                selected.append(framework_type)
        
        return selected[:6]  # Limit to 6 frameworks for manageability
    
    async def _analyze_with_framework(
        self,
        context: ArchitectureContext,
        framework: FrameworkType,
        depth: str
    ) -> Dict[str, Any]:
        """Perform deep analysis using a specific framework"""
        # This will be implemented to call specific framework modules
        # For now, return a structured placeholder
        return {
            "framework": framework.value,
            "analysis": {
                "current_state_assessment": {},
                "gap_analysis": {},
                "recommendations": [],
                "artifacts_needed": [],
                "patterns_identified": [],
                "anti_patterns_detected": [],
                "compliance_status": {}
            },
            "confidence": 0.85,
            "depth": depth
        }
    
    def _create_insights(
        self,
        framework_results: List[Dict[str, Any]],
        patterns: List[Dict[str, Any]],
        recommendations: List[Dict[str, Any]],
        context: ArchitectureContext
    ) -> List[ArchitectureInsight]:
        """Create unified insights from all analysis results"""
        insights = []
        
        # Pattern-based insights
        for pattern in patterns:
            insight = ArchitectureInsight(
                id=f"pattern_{len(insights)}",
                type="pattern",
                title=pattern.get("title", "Pattern Detected"),
                description=pattern.get("description", ""),
                frameworks=[FrameworkType(f) for f in pattern.get("frameworks", [])],
                confidence=pattern.get("confidence", 0.8),
                impact=pattern.get("impact", "medium"),
                effort=pattern.get("effort", "medium"),
                priority=pattern.get("priority", 5),
                rationale=pattern.get("rationale", ""),
                actions=pattern.get("actions", []),
                references=pattern.get("references", [])
            )
            insights.append(insight)
        
        # Recommendation insights
        for rec in recommendations:
            insight = ArchitectureInsight(
                id=f"rec_{len(insights)}",
                type="recommendation",
                title=rec.get("title", "Recommendation"),
                description=rec.get("description", ""),
                frameworks=[FrameworkType(f) for f in rec.get("frameworks", [])],
                confidence=rec.get("confidence", 0.8),
                impact=rec.get("impact", "high"),
                effort=rec.get("effort", "medium"),
                priority=rec.get("priority", 7),
                rationale=rec.get("rationale", ""),
                actions=rec.get("actions", []),
                references=rec.get("references", [])
            )
            insights.append(insight)
        
        # Sort by priority
        insights.sort(key=lambda x: x.priority, reverse=True)
        
        return insights
    
    def _create_executive_summary(self, insights: List[ArchitectureInsight]) -> Dict[str, Any]:
        """Create executive summary from insights"""
        high_priority = [i for i in insights if i.priority >= 8]
        high_impact = [i for i in insights if i.impact == "high"]
        quick_wins = [i for i in insights if i.effort == "low" and i.impact in ["high", "medium"]]
        
        return {
            "total_insights": len(insights),
            "high_priority_items": len(high_priority),
            "high_impact_opportunities": len(high_impact),
            "quick_wins": len(quick_wins),
            "top_recommendations": [
                {
                    "title": i.title,
                    "impact": i.impact,
                    "effort": i.effort,
                    "frameworks": [f.value for f in i.frameworks]
                }
                for i in insights[:5]
            ],
            "key_patterns": [
                i.title for i in insights if i.type == "pattern"
            ][:5],
            "risk_areas": [
                i.title for i in insights if "risk" in i.title.lower() or "warning" in i.type
            ]
        }
    
    def _generate_next_steps(
        self,
        insights: List[ArchitectureInsight],
        context: ArchitectureContext
    ) -> List[Dict[str, Any]]:
        """Generate pragmatic next steps based on insights"""
        next_steps = []
        
        # Group insights by effort and impact
        for insight in insights[:10]:  # Top 10 insights
            if insight.actions:
                step = {
                    "step": insight.actions[0].get("description", insight.title),
                    "priority": insight.priority,
                    "effort": insight.effort,
                    "impact": insight.impact,
                    "framework": insight.frameworks[0].value if insight.frameworks else "general",
                    "timeline": self._estimate_timeline(insight.effort),
                    "dependencies": insight.actions[0].get("dependencies", []),
                    "success_criteria": insight.actions[0].get("success_criteria", [])
                }
                next_steps.append(step)
        
        # Sort by priority and effort (quick wins first)
        next_steps.sort(key=lambda x: (x["effort"] == "low", x["priority"]), reverse=True)
        
        return next_steps
    
    def _estimate_timeline(self, effort: str) -> str:
        """Estimate timeline based on effort level"""
        timelines = {
            "low": "1-2 weeks",
            "medium": "1-2 months",
            "high": "3-6 months"
        }
        return timelines.get(effort, "TBD")
    
    def _cache_insights(self, project_name: str, insights: List[ArchitectureInsight]):
        """Cache insights for learning and improvement"""
        if project_name not in self.insights_cache:
            self.insights_cache[project_name] = []
        self.insights_cache[project_name].extend(insights)
        
        # Limit cache size
        if len(self.insights_cache[project_name]) > 100:
            self.insights_cache[project_name] = self.insights_cache[project_name][-100:]
    
    async def get_framework_capabilities(self, framework: FrameworkType) -> Dict[str, Any]:
        """Get detailed capabilities of a specific framework"""
        if framework not in self.frameworks:
            return {"error": f"Framework {framework.value} not found"}
        
        # This will be implemented to return actual framework capabilities
        return {
            "framework": framework.value,
            "capabilities": [
                "assessment",
                "gap_analysis",
                "artifact_generation",
                "pattern_detection",
                "compliance_checking"
            ],
            "depth_levels": ["basic", "intermediate", "expert"],
            "artifacts": [],
            "techniques": [],
            "patterns": []
        }
    
    async def learn_from_feedback(
        self,
        project_name: str,
        insight_id: str,
        feedback: Dict[str, Any]
    ):
        """Learn from user feedback to improve recommendations"""
        self.feedback_data.append({
            "project": project_name,
            "insight_id": insight_id,
            "feedback": feedback,
            "timestamp": datetime.now().isoformat()
        })
        
        # Update recommendation engine with feedback
        await self.recommendation_engine.update_with_feedback(
            insight_id,
            feedback
        )
        
        self.logger.info(f"Received feedback for insight {insight_id}: {feedback}")
    
    async def export_analysis(
        self,
        analysis_results: Dict[str, Any],
        format: str = "markdown"
    ) -> str:
        """Export analysis results in various formats"""
        if format == "markdown":
            return self._export_as_markdown(analysis_results)
        elif format == "json":
            return json.dumps(analysis_results, indent=2, default=str)
        elif format == "html":
            return self._export_as_html(analysis_results)
        else:
            raise ValueError(f"Unsupported export format: {format}")
    
    def _export_as_markdown(self, results: Dict[str, Any]) -> str:
        """Export analysis as markdown report"""
        md = f"# Architecture Analysis Report\n\n"
        md += f"**Project:** {results['context'].project_name}\n"
        md += f"**Date:** {results['timestamp']}\n"
        md += f"**Frameworks Used:** {', '.join(results['frameworks_used'])}\n\n"
        
        md += "## Executive Summary\n\n"
        summary = results['summary']
        md += f"- **Total Insights:** {summary['total_insights']}\n"
        md += f"- **High Priority Items:** {summary['high_priority_items']}\n"
        md += f"- **Quick Wins:** {summary['quick_wins']}\n\n"
        
        md += "## Top Recommendations\n\n"
        for rec in summary['top_recommendations']:
            md += f"### {rec['title']}\n"
            md += f"- **Impact:** {rec['impact']}\n"
            md += f"- **Effort:** {rec['effort']}\n"
            md += f"- **Frameworks:** {', '.join(rec['frameworks'])}\n\n"
        
        md += "## Next Steps\n\n"
        for i, step in enumerate(results['next_steps'][:5], 1):
            md += f"{i}. **{step['step']}**\n"
            md += f"   - Timeline: {step['timeline']}\n"
            md += f"   - Priority: {step['priority']}/10\n\n"
        
        return md
    
    def _export_as_html(self, results: Dict[str, Any]) -> str:
        """Export analysis as HTML report"""
        # Implementation would create a rich HTML report
        # For now, convert markdown to HTML
        md = self._export_as_markdown(results)
        # Would use a markdown-to-HTML converter here
        return f"<html><body><pre>{md}</pre></body></html>"
    
    async def analyze_architecture_library(
        self,
        library_path: Path,
        context: Optional[ArchitectureContext] = None
    ) -> Dict[str, Any]:
        """
        Analyze a library of architecture books and documents
        
        Args:
            library_path: Path to directory containing PDF documents
            context: Optional architecture context for relevance
            
        Returns:
            Analysis of document relevance and extraction recommendations
        """
        self.logger.info(f"Analyzing architecture library at {library_path}")
        
        # Find all PDF files
        pdf_files = list(library_path.glob("*.pdf"))
        
        # Analyze each document for relevance
        analyzed_documents = []
        for pdf_file in pdf_files:
            try:
                document = await self.knowledge_extractor.analyze_document_relevance(
                    pdf_file,
                    context.__dict__ if context else None
                )
                analyzed_documents.append(document)
            except Exception as e:
                self.logger.warning(f"Failed to analyze {pdf_file}: {e}")
        
        # Sort by relevance
        analyzed_documents.sort(
            key=lambda d: d.relevance_score,
            reverse=True
        )
        
        # Create extraction plans for relevant documents
        extraction_goals = ["patterns", "principles", "frameworks"]
        extraction_plans = await self.knowledge_extractor.create_extraction_plan(
            analyzed_documents,
            extraction_goals,
            [f.value for f in self.frameworks.keys()] if self.frameworks else None
        )
        
        # Get book recommendations
        recommendations = await self.knowledge_extractor.recommend_books_for_context(
            context.__dict__ if context else {},
            self.knowledge_extractor.knowledge_base
        )
        
        return {
            "library_path": str(library_path),
            "total_documents": len(pdf_files),
            "analyzed_documents": len(analyzed_documents),
            "document_analysis": [
                {
                    "filename": doc.filename,
                    "relevance": doc.relevance.value,
                    "relevance_score": doc.relevance_score,
                    "reasons": doc.relevance_reasons,
                    "frameworks": doc.frameworks_covered,
                    "recommended_for_extraction": doc.relevance in [
                        DocumentRelevance.ESSENTIAL,
                        DocumentRelevance.HIGHLY_RELEVANT
                    ]
                }
                for doc in analyzed_documents
            ],
            "extraction_plans": [
                {
                    "document": plan.document.filename,
                    "priority": plan.priority,
                    "estimated_value": plan.estimated_value,
                    "extraction_goals": plan.extraction_goals,
                    "focus_areas": plan.pattern_focus_areas
                }
                for plan in extraction_plans[:10]  # Top 10 plans
            ],
            "recommendations": recommendations,
            "summary": {
                "essential_documents": len([
                    d for d in analyzed_documents 
                    if d.relevance == DocumentRelevance.ESSENTIAL
                ]),
                "highly_relevant_documents": len([
                    d for d in analyzed_documents
                    if d.relevance == DocumentRelevance.HIGHLY_RELEVANT
                ]),
                "relevant_documents": len([
                    d for d in analyzed_documents
                    if d.relevance == DocumentRelevance.RELEVANT
                ])
            }
        }
    
    async def extract_knowledge_from_documents(
        self,
        extraction_plans: List[Dict[str, Any]],
        max_documents: int = 5
    ) -> Dict[str, Any]:
        """
        Execute knowledge extraction from documents
        
        Args:
            extraction_plans: List of extraction plans
            max_documents: Maximum number of documents to process
            
        Returns:
            Extracted knowledge organized by type
        """
        self.logger.info(f"Extracting knowledge from up to {max_documents} documents")
        
        extracted_knowledge = {
            "patterns": [],
            "principles": [],
            "frameworks": {},
            "best_practices": [],
            "case_studies": [],
            "extraction_summary": {}
        }
        
        # Process extraction plans
        for i, plan in enumerate(extraction_plans[:max_documents]):
            try:
                knowledge = await self.knowledge_extractor.extract_knowledge(plan)
                
                # Merge extracted knowledge
                extracted_knowledge["patterns"].extend(knowledge.get("patterns", []))
                extracted_knowledge["principles"].extend(knowledge.get("principles", []))
                extracted_knowledge["best_practices"].extend(knowledge.get("best_practices", []))
                extracted_knowledge["case_studies"].extend(knowledge.get("case_studies", []))
                
                # Merge framework knowledge
                for framework, framework_knowledge in knowledge.get("frameworks", {}).items():
                    if framework not in extracted_knowledge["frameworks"]:
                        extracted_knowledge["frameworks"][framework] = {}
                    extracted_knowledge["frameworks"][framework].update(framework_knowledge)
                
                # Update summary
                extracted_knowledge["extraction_summary"][plan.document.filename] = {
                    "status": "completed",
                    "patterns_extracted": len(knowledge.get("patterns", [])),
                    "principles_extracted": len(knowledge.get("principles", [])),
                    "frameworks_covered": list(knowledge.get("frameworks", {}).keys())
                }
                
            except Exception as e:
                self.logger.error(f"Failed to extract from {plan.document.filename}: {e}")
                extracted_knowledge["extraction_summary"][plan.document.filename] = {
                    "status": "failed",
                    "error": str(e)
                }
        
        # Update knowledge graph with extracted knowledge
        await self.knowledge_graph.update_with_extracted_knowledge(extracted_knowledge)
        
        return extracted_knowledge
    
    async def get_contextual_book_recommendations(
        self,
        context: ArchitectureContext,
        knowledge_gaps: Optional[List[str]] = None
    ) -> List[Dict[str, Any]]:
        """
        Get book recommendations based on context and knowledge gaps
        
        Args:
            context: Current architecture context
            knowledge_gaps: Identified knowledge gaps
            
        Returns:
            Prioritized book recommendations
        """
        # Get recommendations from knowledge extractor
        recommendations = await self.knowledge_extractor.recommend_books_for_context(
            context.__dict__,
            self.knowledge_extractor.knowledge_base
        )
        
        # Enhance with context-specific insights
        enhanced_recommendations = []
        for rec in recommendations:
            enhanced_rec = rec.copy()
            
            # Add relevance to current analysis
            if context.goals:
                relevant_goals = [
                    goal for goal in context.goals
                    if any(topic in goal.lower() for topic in rec.get("topics", []))
                ]
                enhanced_rec["relevant_to_goals"] = relevant_goals
            
            # Add framework alignment
            if context.technical_stack:
                relevant_tech = [
                    tech for tech in context.technical_stack
                    if any(topic in tech.lower() for topic in rec.get("topics", []))
                ]
                enhanced_rec["relevant_to_tech_stack"] = relevant_tech
            
            # Prioritize based on knowledge gaps
            if knowledge_gaps:
                addresses_gaps = [
                    gap for gap in knowledge_gaps
                    if any(gap.lower() in topic.lower() for topic in rec.get("topics", []))
                ]
                enhanced_rec["addresses_knowledge_gaps"] = addresses_gaps
                if addresses_gaps:
                    enhanced_rec["priority"] = "essential"
            
            enhanced_recommendations.append(enhanced_rec)
        
        # Sort by priority
        priority_order = {"essential": 1, "highly_relevant": 2, "relevant": 3, "supplementary": 4}
        enhanced_recommendations.sort(
            key=lambda r: priority_order.get(r.get("priority", "supplementary"), 5)
        )
        
        return enhanced_recommendations